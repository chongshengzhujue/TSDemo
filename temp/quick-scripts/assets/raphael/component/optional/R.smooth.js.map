{"version":3,"sources":["R.smooth.js"],"names":["getFirstControlPoints","rhs","n","length","x","tmp","b","i","getCubicBezierCurvePoints","points","firstControlPoints","secondControlPoints","size","closed","y","overlap","Math","min","knots","j","f1","f2","ie","je","getCubicBezierCurvePath","module","exports","smooth","_commands","forEach","cmd","c","push","cc","p","results","commands","len","firstControlPoint","secondControlPoint","_dirty"],"mappings":"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","file":"R.smooth.js","sourceRoot":"../../../../../../assets/raphael/component/optional","sourcesContent":["'use strict';\n\n// smooth helper\nfunction getFirstControlPoints(rhs) {\n    var n = rhs.length,\n        x = [],     // Solution vector.\n        tmp = [],   // Temp workspace.\n        b = 2.0,\n        i;\n\n    x[0] = rhs[0] / b;\n\n    for (i = 1; i < n; i++) { // Decomposition and forward substitution.\n        tmp[i] = 1 / b;\n        b = (i < n - 1 ? 4.0 : 2.0) - tmp[i];\n        x[i] = (rhs[i] - x[i - 1]) / b;\n    }\n\n    for (i = 1; i < n; i++) {\n        x[n - i - 1] -= tmp[n - i] * x[n - i]; // Backsubstitution.\n    }\n    return x;\n}\n\nfunction getCubicBezierCurvePoints(points, firstControlPoints, secondControlPoints) {\n    var size = points.length,\n        closed = points[size-1].x === points[0].x && points[size-1].y === points[0].y,\n        n = size,\n        // Add overlapping ends for averaging handles in closed paths\n        overlap = 0;\n\n    if (closed) {\n        size = n = size-1;\n    }\n\n    if (size <= 2)\n        return;\n    if (closed) {\n        // Overlap up to 4 points since averaging beziers affect the 4\n        // neighboring points\n        overlap = Math.min(size, 4);\n        n += Math.min(size, overlap) * 2;\n    }\n\n    var knots = [];\n    for (var i = 0; i < size; i++)\n        knots[i + overlap] = points[i];\n    if (closed) {\n        // If we're averaging, add the 4 last points again at the\n        // beginning, and the 4 first ones at the end.\n        for (var i = 0; i < overlap; i++) {\n            knots[i] = points[i + size - overlap];\n            knots[i + size + overlap] = points[i];\n        }\n    } else {\n        n--;\n    }\n    // Calculate first Bezier control points\n    // Right hand side vector\n    var rhs = [];\n\n    // Set right hand side X values\n    for (var i = 1; i < n - 1; i++)\n        rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n    rhs[0] = knots[0].x + 2 * knots[1].x;\n    rhs[n - 1] = 3 * knots[n - 1].x;\n    // Get first control points X-values\n    var x = getFirstControlPoints(rhs);\n\n    // Set right hand side Y values\n    for (var i = 1; i < n - 1; i++)\n        rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n    rhs[0] = knots[0].y + 2 * knots[1].y;\n    rhs[n - 1] = 3 * knots[n - 1].y;\n    // Get first control points Y-values\n    var y = getFirstControlPoints(rhs);\n\n    if (closed) {\n        // Do the actual averaging simply by linearly fading between the\n        // overlapping values.\n        for (var i = 0, j = size; i < overlap; i++, j++) {\n            var f1 = i / overlap,\n                f2 = 1 - f1,\n                ie = i + overlap,\n                je = j + overlap;\n            // Beginning\n            x[j] = x[i] * f1 + x[j] * f2;\n            y[j] = y[i] * f1 + y[j] * f2;\n            // End\n            x[je] = x[ie] * f2 + x[je] * f1;\n            y[je] = y[ie] * f2 + y[je] * f1;\n        }\n        n--;\n    }\n\n    // Now set the calculated handles\n    for (var i = overlap; i <= n - overlap; i++) {\n\n        firstControlPoints[i - overlap] = {\n            x: x[i],\n            y: y[i]\n        };\n\n        if (i < n - 1) {\n            secondControlPoints[i - overlap] = {\n                x: 2 * knots[i + 1].x - x[i + 1],\n                y: 2 * knots[i + 1].y - y[i + 1]\n            };\n        }\n        else {\n            secondControlPoints[i - overlap] = {\n                x: (knots[n].x + x[n - 1]) / 2,\n                y: (knots[n].y + y[n - 1]) / 2\n            };\n        }\n    }\n}\n\nfunction getCubicBezierCurvePath(knots) {\n    var firstControlPoints = [],\n        secondControlPoints = [];\n\n    getCubicBezierCurvePoints(knots, firstControlPoints, secondControlPoints);\n\n    return [firstControlPoints, secondControlPoints];\n}\n\nmodule.exports = {\n    smooth: function () {\n        var knots = [];\n        this._commands.forEach( function (cmd) {\n            var c = cmd[0];\n\n            if (c === 'M') {\n                knots.push( cc.p(cmd[1], cmd[2]) );\n            }\n            else if(c === 'C') {\n                knots.push( cc.p(cmd[5], cmd[6]) );\n            }\n        });\n\n        var results = getCubicBezierCurvePath( knots );\n        var firstControlPoints = results[0];\n        var secondControlPoints = results[1];\n        var commands = [];\n\n        for (var i = 0, len = knots.length; i < len; i++) {\n            if (i === 0) {\n                commands.push(['M', knots[i].x, knots[i].y]);\n            } else {\n                var firstControlPoint = firstControlPoints[i - 1],\n                secondControlPoint = secondControlPoints[i - 1];\n\n                commands.push([\n                    'C', \n                    firstControlPoint.x, firstControlPoint.y,\n                    secondControlPoint.x, secondControlPoint.y,\n                    knots[i].x, knots[i].y\n                ]);\n            }\n        }\n\n        this._commands = commands;\n        this._dirty = true;\n    }\n};\n"]}